#![allow(clippy::all)]
grammar;

use crate::parsing::ast::{Expr, Op, Stmt};
use crate::parsing::lexer::{self, TokenKind, Token, Index};

extern {
    type Location = Index;

    enum lexer::TokenKind {
        BLOCK => TokenKind::BeginBlock,
        BLOCK_END => TokenKind::EndBlock,
        EOL => TokenKind::LineEnd,

        "(" => TokenKind::LParen,
        ")" => TokenKind::RParen,

        "+" => TokenKind::Plus,
        "-" => TokenKind::Minus,
        "*" => TokenKind::Star,
        "/" => TokenKind::Slash,

        "?=" => TokenKind::TestEquals,

        "=" => TokenKind::Equals,

        Num => TokenKind::Number(..),
        Name => TokenKind::Name(..),

        "print" => TokenKind::Print,
        "var" => TokenKind::Var,
        "if" => TokenKind::If,
    }
}

pub Program: Vec<Stmt> = {
    Block,
}

Block: Vec<Stmt> = {
BLOCK <OneOrMoreStatements> BLOCK_END => <>,

}

OneOrMoreStatements: Vec<Stmt> = {
    <mut v: (<Stmt> EOL)*> <e: Stmt?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

LocatedToken<T>: Token = {
    <l:@L> <rule:T> @R => Token {position: l, kind: rule}
}

Stmt: Stmt = {
    PrintStmt,
    VarDeclarationStmt,
    AssignmentStmt,
    ExprStmt,

}

AssignmentStmt: Stmt = {
    <n:LocatedToken<Name>> "=" <e:Expr> => Stmt::Assignment(n, e),
    <n:LocatedToken<Name>> "=" EOL <b:BlockExpr> => Stmt::Assignment(n, b)
}

VarDeclarationStmt: Stmt = {
    "var" <n:LocatedToken<Name>> <e:("=" <Expr>)?> => {
        Stmt::VarDeclaration(n, e)
    }
}

PrintStmt: Stmt = {
    "print" <Expr> => Stmt::Print(<>)
}

ExprStmt: Stmt = {
    <Expr> => Stmt::Expression(<>)
}

BlockExpr: Box<Expr> = {
    <b:Block> => Box::new(Expr::Block(b))
}

Tier<Op,NextTier>: Box<Expr> = {
    <a:Tier<Op,NextTier>> <op:Op> <b:NextTier> => Box::new(Expr::Binary(op, a, b)),
    NextTier
};


Expr: Box<Expr> = {
    Equality,
    IfExpr
}

IfExpr: Box<Expr> = {
    "if" <cond:Equality> EOL <then:Block> => Box::new(Expr::IfExpr(cond, then))
}

Equality = Tier<EqualityOp, Addition>;

Addition = Tier<AdditionOp, Factor>;
Factor = Tier<FactorOp, Term>;

EqualityOp: Op = {
    "?=" => Op::TestEquals
}

AdditionOp: Op = {
    "+" => Op::Add,
    "-" => Op::Sub
}
FactorOp: Op = {
    "*" => Op::Mul,
    "/" => Op::Div
}

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(match <> { TokenKind::Number(n) => n, _ => panic!() })),
    <n:LocatedToken<Name>> => Box::new(Expr::Name(n)),
    "(" <Expr> ")" => <>
}

